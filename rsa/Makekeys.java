/**********************************************
 * Makekeys.java
 * @author SarahGreen
 * UNI: stg2117
 * COMS 3134 Columbia University, Fall 2013
 *********************************************/

package rsa;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Random;

/**
 * The {@link Makekeys} class is used to generate public or private keys for RSA
 * encryption. It uses the RSA algorithm to generate appropriate values, and
 * then creates files containing the public and private keys.
 */
public class Makekeys {

	/** Instance variables */
	private String name;
	private Random rand;
	private int e;
	private int N;
	private int d;

	/** Constructor */
	public Makekeys() {
		name = "";
		rand = new Random();
		e = 0;
		N = 0;
		d = 0;
	}

	/**
	 * Main method to instantiate a Makekeys object, get its name from the
	 * command line, and generate the files containing public/private keys.
	 * 
	 * @param args
	 *            specifies name for files, e.g. "bob"
	 * @throws IOException
	 */
	public static void main(String[] args) throws IOException {
		Makekeys test = new Makekeys();
		test.name = args[0];
		test.RSA();
		test.writePublic();
		test.writePrivate();
	}

	/**
	 * RSA algorithm generates values for the public and private keys.
	 * 
	 * p and q: primes between 64 and 128, destroyed at the end //
	 * 
	 * N: product of p and q //
	 * 
	 * z: product of (p-1) and (q-1) //
	 * 
	 * e: integer smaller than N and relatively prime to z //
	 * 
	 * d: modular multiplicative inverse of e (mod z)
	 * 
	 */
	public void RSA() {
		int p = this.getPrime(64, 128);
		int q = this.getPrime(64, 128);
		N = (p * q);
		int z = ((p - 1) * (q - 1));
		do
			e = rand.nextInt(N);
		while (gcd(e, z) != 1);
		d = this.inverse(e, z);
		p = 0;
		q = 0;
	}

	/**
	 * Locates the modular multiplicative inverse of an int, mod another int,
	 * from the int array returned by the Extended Euclidean Algorithm.
	 * 
	 * @param e
	 *            the integer whose inverse to find
	 * @param z
	 *            the modulus
	 * @return int representing modular multiplicative inverse of e (mod z)
	 */
	public int inverse(int e, int z) {
		int x = e;
		int y = z;
		int[] temp = (ExtEuclid(x, y));
		int inv = temp[1];
		if (inv > 0)
			return inv;
		else
			return (inv + z);
	}

	/**
	 * Generates an int array with the gcd and Bezout coefficients
	 * (respectively) generated by the Extended Euclidean Algorithm.
	 * 
	 * @param a
	 *            the integer whose inverse to find
	 * @param b
	 *            the modulus
	 * @return int[] representing gcd and Bezout coefficients
	 */
	public int[] ExtEuclid(int a, int b) {
		int[] ans = new int[3];
		int q;
		if (b == 0) {
			ans[0] = a;
			ans[1] = 1;
			ans[2] = 0;
		} else {
			ans = ExtEuclid(b, a % b);
			q = (int) Math.floor(a / b);
			int temp = ans[1] - (ans[2] * q);
			ans[1] = ans[2];
			ans[2] = temp;
		}
		return ans;
	}

	/**
	 * Recursively computes the greatest common denominator of two specified
	 * numbers.
	 * 
	 * @param a
	 *            first number
	 * @param b
	 *            second number
	 * @return int representing their greatest common denominator
	 */
	public int gcd(int a, int b) {
		if (b == 0)
			return a;
		return gcd(b, a % b);
	}

	/**
	 * Gets a prime number within a specified range. Generates a random int
	 * between the maximum and minimum allowed, checking if it is prime, until
	 * the generated int is prime.
	 * 
	 * @param min
	 *            bottom of the range
	 * @param max
	 *            top of the range
	 * @return a random prime within the range
	 */
	public int getPrime(int min, int max) {
		int prime;
		do
			prime = rand.nextInt(max - min) + min;
		while (!isPrime(prime));
		return prime;
	}

	/**
	 * Checks if a number is prime or not, using the Sieve of Eratosthenes.
	 * 
	 * @param n
	 *            number to check if prime
	 * @return true if n is prime, false otherwise
	 */
	public boolean isPrime(int n) {
		int sqrtN = (int) Math.sqrt(n);
		boolean[] sieve = new boolean[sqrtN];
		int i;
		for (i = 2; i < sqrtN; i++)
			sieve[i] = true;
		for (int p = 2; p < sqrtN; p++) {
			if (sieve[p]) {
				for (i = 2 * p; i < sqrtN; i += p)
					sieve[i] = false;
			}
		}
		for (i = 2; i < sqrtN; i++) {
			if (sieve[i] && n % i == 0)
				return false;
		}
		return true;
	}

	/**
	 * Makes the public key file. Creates a new file with the name specified in
	 * the command line, and writes ints e and N to it.
	 * 
	 * @throws IOException
	 */
	public void writePublic() throws IOException {
		File pubFile = new File(name + ".public");
		pubFile.createNewFile();
		FileWriter writer = new FileWriter(pubFile);
		writer.write(e + "\n" + N);
		writer.flush();
		writer.close();
	}

	/**
	 * Makes the private key file. Creates a new file with the name specified in
	 * the command line, and writes ints d and N to it.
	 * 
	 * @throws IOException
	 */
	public void writePrivate() throws IOException {
		File pubFile = new File(name + ".private");
		pubFile.createNewFile();
		FileWriter writer = new FileWriter(pubFile);
		writer.write(d + "\n" + N);
		writer.flush();
		writer.close();
	}

}